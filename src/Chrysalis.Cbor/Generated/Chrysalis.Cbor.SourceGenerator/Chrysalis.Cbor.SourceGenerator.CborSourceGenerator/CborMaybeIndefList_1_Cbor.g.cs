    #nullable enable
    // <auto-generated/>
    #pragma warning disable CS0109 // Ignore warnings about unnecessary 'new' keyword
    #pragma warning disbale CS0693
    #pragma warning disbale CS8604
    #pragma warning disbale CS8600
    #pragma warning disbale CS8603
    using System;
    using System.Collections.Generic;
    using System.Formats.Cbor;
    using System.Reflection;
    using Chrysalis.Cbor.Types;
    using Chrysalis.Cbor.Types.Custom;
    using Chrysalis.Cbor.Serialization.Attributes;
    

    namespace Chrysalis.Cbor.Types.Custom;

    // Partial class for closed generic type with concrete type parameters
    public partial record CborMaybeIndefList<int>
    {
        
        
        // Serialization implementation
        public static new void Write(CborWriter writer, global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int> value)
        {
            // Determine the concrete type from its type name
switch (value.CborTypeName)
{
    case "CborDefList":
        global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborDefList.Write(writer, (global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborDefList)value);
        break;
    case "CborIndefList":
        global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborIndefList.Write(writer, (global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborIndefList)value);
        break;
    case "CborDefListWithTag":
        global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborDefListWithTag.Write(writer, (global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborDefListWithTag)value);
        break;
    case "CborIndefListWithTag":
        global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborIndefListWithTag.Write(writer, (global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborIndefListWithTag)value);
        break;
    default:
        throw new Exception($"Unknown union type: {value.CborTypeName}");
}

        }

        // Deserialization implementation
        public static new global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>? Read(ReadOnlyMemory<byte> data, bool preserveRaw = false)
        {
            // Try each union case
var originalData = data;
Exception lastException = null;
// Try CborDefList
try
{
    var result = global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborDefList.Read(originalData, preserveRaw);
    return result; // Successfully deserialized and validated
}
catch (Exception ex)
{
    lastException = ex;
    // Continue to the next case
}
// Try CborIndefList
try
{
    var result = global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborIndefList.Read(originalData, preserveRaw);
    return result; // Successfully deserialized and validated
}
catch (Exception ex)
{
    lastException = ex;
    // Continue to the next case
}
// Try CborDefListWithTag
try
{
    var result = global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborDefListWithTag.Read(originalData, preserveRaw);
    return result; // Successfully deserialized and validated
}
catch (Exception ex)
{
    lastException = ex;
    // Continue to the next case
}
// Try CborIndefListWithTag
try
{
    var result = global::Chrysalis.Cbor.Types.Custom.CborMaybeIndefList<int>.CborIndefListWithTag.Read(originalData, preserveRaw);
    return result; // Successfully deserialized and validated
}
catch (Exception ex)
{
    lastException = ex;
    // Continue to the next case
}
throw new Exception("Could not deserialize union type", lastException);

        }
        
        
            // Generic deserialization helper
            private static T DeserializeGenericValue<T>(ReadOnlyMemory<byte> data)
            {
                // This is a placeholder - in real code, you would need to 
                // route to the appropriate deserializer based on the runtime type
                
                // For primitive types, handle directly
                var reader = new CborReader(data);
                
                // Detect the data type and convert accordingly
                switch (reader.PeekState())
                {
                    case CborReaderState.UnsignedInteger:
                        var uint64Value = reader.ReadUInt64();
                        // Try to convert to T
                        return (T)Convert.ChangeType(uint64Value, typeof(T));
                        
                    case CborReaderState.NegativeInteger:
                        var int64Value = reader.ReadInt64();
                        return (T)Convert.ChangeType(int64Value, typeof(T));
                        
                    case CborReaderState.TextString:
                        var strValue = reader.ReadTextString();
                        return (T)Convert.ChangeType(strValue, typeof(T));
                        
                    case CborReaderState.ByteString:
                        var bytesValue = reader.ReadByteString();
                        // If T is byte[] or compatible
                        if (typeof(T) == typeof(byte[]))
                            return (T)(object)bytesValue;
                        break;
                        
                    // Add cases for other CBOR types as needed
                }
                
                // For complex types, try to find and invoke the Read method
                var type = typeof(T);
                var readMethod = type.GetMethod("Read", 
                    System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, 
                    null, 
                    new[] { typeof(ReadOnlyMemory<byte>), typeof(bool) }, 
                    null);
                    
                if (readMethod != null)
                {
                    return (T)readMethod.Invoke(null, new object[] { data, false });
                }
                
                // Default fallback
                throw new InvalidOperationException($"Cannot deserialize to type {typeof(T).Name}");
            }
        
            /// <summary>
    /// Writes any generic type to a CBOR writer based on runtime type
    /// </summary>
    private static void WriteGenericValue<T>(CborWriter writer, T value)
    {
        if (value == null)
        {
            writer.WriteNull();
            return;
        }

        Type valueType = value.GetType();

        // Handle primitive types first (most common case)
        if (valueType == typeof(int))
            writer.WriteInt32((int)(object)value);
        else if (valueType == typeof(uint))
            writer.WriteUInt32((uint)(object)value);
        else if (valueType == typeof(long))
            writer.WriteInt64((long)(object)value);
        else if (valueType == typeof(ulong))
            writer.WriteUInt64((ulong)(object)value);
        else if (valueType == typeof(float))
            writer.WriteSingle((float)(object)value);
        else if (valueType == typeof(double))
            writer.WriteDouble((double)(object)value);
        else if (valueType == typeof(decimal))
            writer.WriteDouble((double)(decimal)(object)value);
        else if (valueType == typeof(bool))
            writer.WriteBoolean((bool)(object)value);
        else if (valueType == typeof(string))
            writer.WriteTextString((string)(object)value);
        else if (valueType == typeof(byte[]))
            writer.WriteByteString((byte[])(object)value);
        else if (valueType == typeof(DateTime))
            writer.WriteTextString(((DateTime)(object)value).ToString("o"));
        else if (valueType == typeof(Guid))
            writer.WriteTextString(((Guid)(object)value).ToString());
        else
        {
            // Check if the type has a Raw property for direct serialization
            PropertyInfo rawProperty = valueType.GetProperty("Raw");
            if (rawProperty != null && 
                rawProperty.PropertyType.IsGenericType && 
                rawProperty.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>) &&
                rawProperty.PropertyType.GetGenericArguments()[0] == typeof(ReadOnlyMemory<byte>))
            {
                var rawValue = rawProperty.GetValue(value);
                if (rawValue != null)
                {
                    var memory = (ReadOnlyMemory<byte>?)rawValue;
                    if (memory.HasValue)
                    {
                        writer.WriteEncodedValue(memory.Value.Span);
                        return;
                    }
                }
            }

            // Try to find and invoke a static Write method
            MethodInfo writeMethod = valueType.GetMethod("Write", 
                BindingFlags.Public | BindingFlags.Static, 
                null, 
                new[] { typeof(CborWriter), valueType }, 
                null);
                
            if (writeMethod != null)
            {
                writeMethod.Invoke(null, new object[] { writer, value });
                return;
            }
            
            // Final fallback
            writer.WriteTextString(value.ToString());
        }
    }
    }
    #pragma warning restore CS0109
    #pragma warning restore CS0693
    #pragma warning restore CS8604
    #pragma warning restore CS8600
    #pragma warning restore CS8603