using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Chrysalis.Cbor.SourceGenerator;

public sealed partial class CborSourceGenerator
{
    /// <summary>
    /// Handles emitting source code for serialization
    /// </summary>
    private class Emitter(SourceProductionContext context)
    {
        private readonly SourceProductionContext _context = context;
        private readonly HashSet<string> _usedHintNames = [];

        /// <summary>
        /// Emits source code for all types in the serialization context
        /// </summary>
        public void Emit(SerializationContext serializationContext)
        {
            foreach (var type in serializationContext.Types)
            {
                _context.CancellationToken.ThrowIfCancellationRequested();

                // Get the appropriate emitter strategy for the type
                var strategy = GetEmitterStrategy(type);

                // Generate the source code
                string sourceCode = GenerateSourceCode(type, strategy);

                string baseName = $"{type.Type.Name}_Cbor.g.cs";
                if (_usedHintNames.Contains(baseName)) continue;
                _usedHintNames.Add(baseName);
                // Generate a unique hint name 
                //string uniqueHintName = GetUniqueHintName(type);

                // Add the source
                _context.AddSource(baseName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        }

        /// <summary>
        /// Creates a unique hint name for the source file
        /// </summary>
        private string GetUniqueHintName(SerializableType type)
        {
            // Start with a simple name
            string baseName = $"{type.Type.Name}_Cbor.g.cs";

            // If it's unique, use it
            if (!_usedHintNames.Contains(baseName))
            {
                _usedHintNames.Add(baseName);
                return baseName;
            }

            // Otherwise, create a name with namespace
            string sanitizedNamespace = type.Type.Namespace.Replace(".", "_");
            string nameWithNamespace = $"{sanitizedNamespace}_{type.Type.Name}_Cbor.g.cs";

            if (!_usedHintNames.Contains(nameWithNamespace))
            {
                _usedHintNames.Add(nameWithNamespace);
                return nameWithNamespace;
            }

            // If still not unique, add a counter
            int counter = 1;
            string nameWithCounter;
            do
            {
                nameWithCounter = $"{sanitizedNamespace}_{type.Type.Name}_{counter}_Cbor.g.cs";
                counter++;
            } while (_usedHintNames.Contains(nameWithCounter));

            _usedHintNames.Add(nameWithCounter);
            return nameWithCounter;
        }

        /// <summary>
        /// Get the appropriate emitter strategy for a type
        /// </summary>
        private IEmitterStrategy GetEmitterStrategy(SerializableType type)
        {
            // Switch on the serialization format to get the right strategy
            return type.Format switch
            {
                SerializationType.Map => new MapEmitterStrategy(),
                SerializationType.Array => new ArrayEmitterStrategy(),
                SerializationType.Constr => new ConstrEmitterStrategy(),
                SerializationType.Union => new UnionEmitterStrategy(),
                SerializationType.Container => new ContainerEmitterStrategy(),
                SerializationType.Nullable => CreateNullableStrategy(type),
                _ => new MapEmitterStrategy() // Default
            };
        }

        /// <summary>
        /// Creates a nullable strategy with the appropriate inner strategy
        /// </summary>
        private NullableEmitterStrategy CreateNullableStrategy(SerializableType type)
        {
            return new NullableEmitterStrategy(type.InnerType!);
        }

        /// <summary>
        /// Generates the complete source code for a type
        /// </summary>
        private string GenerateSourceCode(SerializableType type, IEmitterStrategy strategy)
        {
            string serializerCode = strategy.EmitSerializer(type);
            string deserializerCode = strategy.EmitDeserializer(type);

            return $$"""
                // <auto-generated/>
                using System;
                using System.Collections.Generic;
                using System.Formats.Cbor;
                using Chrysalis.Cbor.Types;

                namespace {{type.Type.Namespace}};

                public partial {{GetTypeKeyword(type)}} {{type.Type.Name}}
                {
                    // Serialization implementation
                    public static new void Write(CborWriter writer, {{type.Type.FullName}} value)
                    {
                        {{serializerCode}}
                    }

                    // Deserialization implementation
                    public static new {{type.Type.FullName}} Read(ReadOnlyMemory<byte> data)
                    {
                        {{deserializerCode}}
                    }   
                }
                """;
        }

        /// <summary>
        /// Determines the C# keyword for the type declaration
        /// </summary>
        private string GetTypeKeyword(SerializableType type)
        {
            if (type.Type.IsRecord)
                return "record";
            else if (!type.Type.IsValueType)
                return "class";
            else
                return "struct";
        }
    }

    /// <summary>
    /// Strategy interface for emitting different types of CBOR serialization
    /// </summary>
    private interface IEmitterStrategy
    {
        string EmitSerializer(SerializableType type);
        string EmitDeserializer(SerializableType type);
    }


    /// <summary>
    /// Base implementation for emitter strategies
    /// </summary>
    private abstract class EmitterStrategyBase : IEmitterStrategy
    {
        public virtual string EmitSerializer(SerializableType type)
        {
            return "// Not implemented";
        }

        public virtual string EmitDeserializer(SerializableType type)
        {
            return "// Not implemented";
        }
    }

    /// <summary>
    /// Strategy for emitting Map type serialization
    /// </summary>
    private class MapEmitterStrategy : EmitterStrategyBase
    {
        public override string EmitSerializer(SerializableType type)
        {
            var sb = new StringBuilder();

            // Tag if needed
            if (type.Tag.HasValue)
            {
                sb.AppendLine($"writer.WriteTag({type.Tag.Value});");
            }

            // Start the map
            sb.AppendLine("writer.WriteStartMap(null);");

            // Write each property
            foreach (var prop in type.Properties)
            {
                sb.AppendLine($"// Write property: {prop.Name}");
                sb.AppendLine($"writer.WriteTextString(\"{prop.Key}\");");
                sb.AppendLine(GenericEmitterStrategy.GenerateWriteCode($"value.{prop.Name}", prop.Type.FullName, !prop.Type.IsValueType));
            }

            sb.AppendLine("writer.WriteEndMap();");

            return sb.ToString();
        }

        public override string EmitDeserializer(SerializableType type)
        {
            var sb = new StringBuilder();

            // Store the original data for later
            sb.AppendLine("var originalData = data;");
            sb.AppendLine("var reader = new CborReader(data.Span);");

            // Tag if needed
            if (type.Tag.HasValue)
            {
                sb.AppendLine($"if (reader.ReadTag() != {type.Tag.Value}) throw new Exception(\"Invalid tag\");");
            }

            // Start reading the map
            sb.AppendLine("reader.ReadStartMap();");

            // Declare local variables for properties
            foreach (var prop in type.Properties)
            {
                sb.AppendLine($"{prop.Type.FullName} {prop.Name} = default;");
            }

            // Read map entries
            sb.AppendLine("while (reader.PeekState() != CborReaderState.EndMap)");
            sb.AppendLine("{");
            sb.AppendLine("    string key = reader.ReadTextString();");
            sb.AppendLine("    switch (key)");
            sb.AppendLine("    {");

            foreach (var prop in type.Properties)
            {
                sb.AppendLine($"        case \"{prop.Key}\":");
                sb.AppendLine($"            {GenericEmitterStrategy.GenerateReadCode(prop.Type.FullName, prop.Name, !prop.Type.IsValueType)}");
                sb.AppendLine("            break;");
            }

            sb.AppendLine("        default:");
            sb.AppendLine("            reader.Skip();");
            sb.AppendLine("            break;");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine("reader.ReadEndMap();");

            // Create the result and store raw bytes
            sb.AppendLine($"var result = new {type.Type.FullName}(");
            for (int i = 0; i < type.Properties.Count; i++)
            {
                var prop = type.Properties[i];
                string suffix = i < type.Properties.Count - 1 ? "," : "";
                sb.AppendLine($"    {prop.Name}: {prop.Name}{suffix}");
            }
            sb.AppendLine(");");
            sb.AppendLine("result.Raw = originalData;");

            sb.AppendLine("return result;");

            return sb.ToString();
        }
    }

    /// <summary>
    /// Strategy for emitting Array type serialization
    /// </summary>
    private class ArrayEmitterStrategy : EmitterStrategyBase
    {
        public override string EmitSerializer(SerializableType type)
        {
            return "// Array serialization not implemented";
        }

        public override string EmitDeserializer(SerializableType type)
        {
            return "// Array deserialization not implemented";
        }
    }

    /// <summary>
    /// Strategy for emitting Constructor type serialization
    /// </summary>
    private class ConstrEmitterStrategy : EmitterStrategyBase
    {
        public override string EmitSerializer(SerializableType type)
        {
            return "// Constr serialization not implemented";
        }

        public override string EmitDeserializer(SerializableType type)
        {
            return "// Constr deserialization not implemented";
        }
    }

    /// <summary>
    /// Strategy for emitting Union type serialization
    /// </summary>
    private class UnionEmitterStrategy : EmitterStrategyBase
    {
        public override string EmitSerializer(SerializableType type)
        {
            var sb = new StringBuilder();

            // Use the CborTypeName property instead of GetType()
            sb.AppendLine("// Determine the concrete type from its type name");
            sb.AppendLine("switch (value.CborTypeName)");
            sb.AppendLine("{");

            foreach (var unionCase in type.UnionCases)
            {
                sb.AppendLine($"    case \"{unionCase.Name}\":");
                sb.AppendLine($"        {unionCase.FullName}.Write(writer, ({unionCase.FullName})value);");
                sb.AppendLine("        break;");
            }

            sb.AppendLine("    default:");
            sb.AppendLine("        throw new Exception($\"Unknown union type: {value.CborTypeName}\");");
            sb.AppendLine("}");

            return sb.ToString();
        }

        public override string EmitDeserializer(SerializableType type)
        {
            var sb = new StringBuilder();

            // Try each case until one succeeds
            sb.AppendLine("// Try each union case");
            sb.AppendLine("var originalData = data;");
            sb.AppendLine("Exception lastException = null;");

            foreach (var unionCase in type.UnionCases)
            {
                sb.AppendLine($"// Try {unionCase.Name}");
                sb.AppendLine("try");
                sb.AppendLine("{");
                sb.AppendLine($"    var result = {unionCase.FullName}.Read(originalData);");
                sb.AppendLine("    return result;");
                sb.AppendLine("}");
                sb.AppendLine("catch (Exception ex)");
                sb.AppendLine("{");
                sb.AppendLine("    lastException = ex;");
                sb.AppendLine("}");
            }

            sb.AppendLine("throw new Exception(\"Could not deserialize union type\", lastException);");

            return sb.ToString();
        }
    }

    /// <summary>
    /// Strategy for emitting Container type serialization
    /// </summary>
    private class ContainerEmitterStrategy : EmitterStrategyBase
    {
        public override string EmitSerializer(SerializableType type)
        {
            return "// Container serialization not implemented";
        }

        public override string EmitDeserializer(SerializableType type)
        {
            return "// Container deserialization not implemented";
        }
    }

    /// <summary>
    /// Strategy for emitting Nullable type serialization
    /// </summary>
    private class NullableEmitterStrategy(TypeInfo innerTypeInfo) : EmitterStrategyBase
    {

        public override string EmitSerializer(SerializableType type)
        {
            return """
                // Nullable serialization wrapper
                if (value == null)
                {
                    writer.WriteNull();
                    return;
                }
                
                // Inner serialization (not implemented)
                """;
        }

        public override string EmitDeserializer(SerializableType type)
        {
            return """
                // Nullable deserialization wrapper
                if (reader.PeekState() == CborReaderState.Null)
                {
                    reader.ReadNull();
                    return null;
                }
                
                // Inner deserialization (not implemented)
                return default;
                """;
        }
    }
}
